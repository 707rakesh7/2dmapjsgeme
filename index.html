<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Multiplayer Dot Game</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: sans-serif; }
        #gameArea { height: 55vh; width: 100vw; background: #1b3d19; position: relative; overflow: hidden; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 5px; pointer-events: none; }
        #controls { height: 45vh; background: #151515; display: flex; justify-content: space-around; align-items: center; border-top: 3px solid #444; }
        .grid { display: grid; grid-template-columns: repeat(3, 65px); gap: 10px; }
        .btn { width: 65px; height: 65px; background: #333; color: white; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 20px; border: 2px solid #555; touch-action: none; }
        .shoot-btn { width: 90px; height: 90px; background: #ff3333; border-color: #900; font-weight: bold; }
        #zoomControl { position: absolute; top: 10px; right: 10px; }
    </style>
</head>
<body>
    <div id="gameArea">
        <div id="ui">HP: <span id="hp">100</span> | Players: <span id="pCount">1</span></div>
        <div id="zoomControl"><input type="range" id="zoom" min="0.5" max="1.5" step="0.1" value="0.8"></div>
        <canvas id="canvas"></canvas>
    </div>
    <div id="controls">
        <div class="grid">
            <div></div> <div class="btn" id="up">W</div> <div></div>
            <div class="btn" id="left">A</div> <div class="btn" id="down">S</div> <div class="btn" id="right">D</div>
        </div>
        <div class="btn shoot-btn" id="shoot">FIRE</div>
    </div>

<script>
const socket = io();
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight * 0.55;

let player = { x: 200, y: 200, r: 12, hp: 100, speed: 4 };
let lastDir = { x: 1, y: 0 };
let otherPlayers = {};
let enemies = [];
let bullets = [];
let zoom = 0.8;

// रूम और दरवाजे
const rooms = [ {x:50, y:50, w:400, h:400}, {x:600, y:100, w:500, h:350} ];
const doors = [ {x:450, y:200, w:150, h:80} ];

const keys = {};
const bind = (id, k) => {
    const el = document.getElementById(id);
    el.onpointerdown = (e) => { e.preventDefault(); keys[k] = true; if(id==='shoot') fire(); };
    el.onpointerup = (e) => { e.preventDefault(); keys[k] = false; };
};
['up','down','left','right','shoot'].forEach(k => bind(k, k));

function fire() {
    bullets.push({ x: player.x, y: player.y, vx: lastDir.x*10, vy: lastDir.y*10, life: 60 });
}

function checkCollision(nx, ny) {
    const inRoom = rooms.some(r => nx > r.x && nx < r.x+r.w && ny > r.y && ny < r.y+r.h);
    const inDoor = doors.some(d => nx > d.x && nx < d.x+d.w && ny > d.y && ny < d.y+d.h);
    return inRoom || inDoor;
}

function update() {
    let dx = 0, dy = 0;
    if(keys.up) dy = -1; if(keys.down) dy = 1;
    if(keys.left) dx = -1; if(keys.right) dx = 1;

    if(dx !== 0 || dy !== 0) {
        lastDir = {x: dx, y: dy};
        if(checkCollision(player.x + dx*player.speed, player.y + dy*player.speed)) {
            player.x += dx*player.speed;
            player.y += dy*player.speed;
        }
    }

    // एनिमी स्पॉन और पीछा करना (Slow AI)
    if(enemies.length < 3) enemies.push({x: 700, y: 200, r: 10, speed: 0.7});
    enemies.forEach((en, i) => {
        let d = Math.hypot(player.x - en.x, player.y - en.y);
        en.x += ((player.x - en.x)/d) * en.speed;
        en.y += ((player.y - en.y)/d) * en.speed;
        if(d < 20) player.hp -= 0.1;
        
        bullets.forEach((b, bi) => {
            if(Math.hypot(b.x - en.x, b.y - en.y) < 20) {
                enemies.splice(i, 1); bullets.splice(bi, 1);
            }
        });
    });

    bullets.forEach((b, i) => { b.x += b.vx; b.y += b.vy; b.life--; if(b.life<=0) bullets.splice(i,1); });

    socket.emit('playerMove', { x: player.x, y: player.y, health: player.hp });
    document.getElementById('hp').innerText = Math.floor(player.hp);
    document.getElementById('pCount').innerText = Object.keys(otherPlayers).length + 1;
}

socket.on('updatePlayers', (data) => { otherPlayers = data; });

function draw() {
    zoom = document.getElementById('zoom').value;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.translate(-player.x*zoom + canvas.width/2, -player.y*zoom + canvas.height/2);
    ctx.scale(zoom, zoom);

    ctx.fillStyle = '#000';
    rooms.forEach(r => ctx.fillRect(r.x, r.y, r.w, r.h));
    doors.forEach(d => ctx.fillRect(d.x, d.y, d.w, d.h));

    // ग्लो इफेक्ट
    ctx.shadowBlur = 15;
    
    // अन्य प्लेयर्स
    for(let id in otherPlayers) {
        if(id !== socket.id) {
            ctx.shadowColor = '#0f0'; ctx.fillStyle = '#8f8';
            ctx.beginPath(); ctx.arc(otherPlayers[id].x, otherPlayers[id].y, 12, 0, Math.PI*2); ctx.fill();
        }
    }

    // प्लेयर
    ctx.shadowColor = '#0ff'; ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill();

    // एनिमी
    ctx.shadowColor = 'red'; ctx.fillStyle = 'red';
    enemies.forEach(en => { ctx.beginPath(); ctx.arc(en.x, en.y, en.r, 0, Math.PI*2); ctx.fill(); });

    ctx.shadowBlur = 0;
    ctx.fillStyle = 'yellow';
    bullets.forEach(b => ctx.fillRect(b.x, b.y, 8, 8));

    requestAnimationFrame(() => { update(); draw(); });
}
draw();
</script>
</body>
</html>